#include <iostream>
#include <sstream>

//using namespace std;

//denominator numerator greatest common divisor
struct Rational
{
	//Конструкторы
	Rational() = default;
	explicit Rational(const int numerator);
	Rational(const int numarator, const int denominator);

	//булева операторы и просто операторы(без тела) Тупо объявляем, за исключением булев.
	bool operator==(const Rational& rhs){
		return (num == rhs.num) && (den == rhs.den); //в упрощенном варианте. Ибо дроби 1/2 = 2/4 и т.п.
	}
	bool operator!=(const Rational& rhs) {
		return !(operator==(rhs));
	}

	Rational& operator+=(const Rational& rhs);
	Rational& operator+=(const int numerator) { return operator+=(Rational(numerator)); } //если решим прибавить просто число

	Rational& operator-=(const Rational& rhs);
	Rational& operator-=(const int numerator) { return operator-=(Rational(numerator)); }

	Rational& operator*=(const Rational& rhs);
	Rational& operator*=(const int numerator) { return operator*=(Rational(numerator)); }

	Rational& operator/=(const Rational& rhs);
	Rational& operator/=(const int numerator) {return operator/=(Rational(numerator)); }

	std::ostream& writeTo(std::ostream& ostrm) const; //операторы
	std::istream& readFrom(std::istream& istrm); //не const!!! 
	
	int GCD(const Rational& rhs); //greatest common divisor НОД

	void normalize();


	int num{ 0 };//numerator
	int den{ 1 };//denominator

	static const char leftBrace{ '{' };
	static const char separator{ '/' };
	static const char rightBrace{ '}' };

};







inline std::ostream& operator <<(std::ostream& ostrm, const Rational& rhs) {
	return rhs.writeTo(ostrm);
}
inline std::istream& operator >>(std::istream& istrm, Rational& rhs) {
	return rhs.readFrom(istrm);
}


//тупо скопипастино
bool testParse(const std::string& str)
{
	using namespace std;
	istringstream istrm(str);
	Rational z;
	istrm >> z;
	if (istrm.good()) {
		cout << "Read success: " << str << " -> " << z << endl;
	}
	else {
		cout << "Read error  : " << str << " -> " << z << endl;
	}
	return istrm.good();
}

int main() 
{
	std::cout << "Hello" << std::endl;

	Rational x(5,7); Rational y(8, 9);
	Rational sum = x;
	sum += y;
	Rational dif = x;
	dif -= y;
	Rational multi = x ;
	multi *= y;
	Rational div = x;
	div /= y;

	testParse("{67/3}");
	testParse("{54     /3}");
	testParse("{54     /3");
	testParse("{67/            3}");


	return 0;
}




//описываем функции и конструкторы
//можно использовать рекурентную функцию!!!!!!!!!!!! Это гораздо лучше твоего дерьма

int GCD1(int max, int min) {
	if (min == 0) return max;
	else return GCD1(min, max%min);

}
//мое дерьмо
int Rational::GCD(const Rational& rhs) 
{
	int max = rhs.den; 
	int min = den;
	if (den > rhs.den)
	{
		int max = den; int min = rhs.den;
	}
	while (max%min != 0)
	{
		int boofer = max;
		max = min;
		min = boofer % min; 
	}

	return min;

	
}


Rational::Rational(const int numerator) :Rational(numerator, 1) {

}
Rational::Rational(const int numarator, const int denumenator)
	: num(numarator)
	, den(denumenator){

}

Rational& Rational::operator+=(const Rational& rhs) {
	
	if (rhs.den == den) { num += rhs.num; }
	else 
	{ 
		int a = 1;
		//int a = GCD(rhs); 
		if (rhs.den > den) a = GCD1(rhs.den, den);
		else a = GCD1(den, rhs.den);
		num = (num * rhs.den  + rhs.num*den) / a;
		den = den * (rhs.den / a);
	}

	return *this;
}


Rational& Rational::operator-=(const Rational& rhs) {
	if (rhs.den == den) {
		num -= rhs.num;
	}
	else
	{
		int a = 1;
		//int a = GCD(rhs); 
		if (rhs.den > den) a = GCD1(rhs.den, den);
		else a = GCD1(den, rhs.den);
		num = (num * rhs.den - rhs.num*den) / a;
		den = den * (rhs.den / a);
	}

	return *this;
}

Rational& Rational::operator*=(const Rational& rhs) {
	num *= rhs.num;
	den *= rhs.den;
	return *this;
}

Rational& Rational::operator/=(const Rational& rhs) {
	num *= rhs.den;
	den *= rhs.num;
	return *this;
}

Rational operator+(const Rational& lhs, const Rational& rhs) {
	Rational sum(lhs);
	sum += rhs;
	return sum;
}
Rational operator-(const Rational& lhs, const Rational& rhs) {
	Rational dif(lhs);
	dif -= rhs;
	return dif;
}

Rational operator*(const Rational& lhs, const Rational& rhs) {
	Rational multi(lhs);
	multi *= rhs;
	return multi;
}
Rational operator/(const Rational& lhs, const Rational& rhs) {
	Rational div(lhs);
	div /= rhs;
	return div;
}


std::ostream& Rational::writeTo(std::ostream& ostrm) const {
	ostrm << leftBrace << num << separator << den << rightBrace;
	return ostrm;
}

std::istream& Rational::readFrom(std::istream& istrm) {
	char leftBrace(0);
	int numerator(0);
	char comma(0);
	int denumerator(1);
	char rightBrace(0);
	istrm >> leftBrace >> numerator >> comma >> denumerator >> rightBrace;
	if (istrm.good()) {
		if ((Rational::leftBrace == leftBrace) && (Rational::rightBrace == rightBrace) && (Rational::separator == comma)) {
			num = numerator;
			den = denumerator;
		}
		else {
			istrm.setstate(std::ios_base::failbit);
		}
	}

	return istrm;
}

void Rational::normalize() {
	if (num != 0 && den != 0) {
		int comma = 1;
		if (num >= den) comma = GCD1(num, den);
		else comma = GCD1(den, num);
		num /= comma;
		den /= comma;
	}
	if (den < 0) {
		num *= -1;
		den *= -1;
	}
}
